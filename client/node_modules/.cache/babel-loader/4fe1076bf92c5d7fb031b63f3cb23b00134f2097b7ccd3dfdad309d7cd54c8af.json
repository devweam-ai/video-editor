{"ast":null,"code":"var _jsxFileName = \"/Users/kshitijvarma/Desktop/ai-doc-editor/AI-VideoGen/client/src/context/VideoContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useReducer, useEffect } from 'react';\nimport axios from 'axios';\nimport toast from 'react-hot-toast';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst VideoContext = /*#__PURE__*/createContext();\nconst initialState = {\n  videos: [],\n  currentVideo: null,\n  loading: false,\n  error: null,\n  pagination: {\n    page: 1,\n    limit: 10,\n    total: 0,\n    pages: 0\n  }\n};\nconst videoReducer = (state, action) => {\n  var _state$currentVideo;\n  switch (action.type) {\n    case 'SET_LOADING':\n      return {\n        ...state,\n        loading: action.payload\n      };\n    case 'SET_ERROR':\n      return {\n        ...state,\n        error: action.payload,\n        loading: false\n      };\n    case 'SET_VIDEOS':\n      return {\n        ...state,\n        videos: action.payload.videos,\n        pagination: action.payload.pagination,\n        loading: false\n      };\n    case 'ADD_VIDEO':\n      return {\n        ...state,\n        videos: [action.payload, ...state.videos],\n        currentVideo: action.payload,\n        loading: false\n      };\n    case 'UPDATE_VIDEO':\n      return {\n        ...state,\n        videos: state.videos.map(video => video.videoId === action.payload.videoId ? action.payload : video),\n        currentVideo: ((_state$currentVideo = state.currentVideo) === null || _state$currentVideo === void 0 ? void 0 : _state$currentVideo.videoId) === action.payload.videoId ? action.payload : state.currentVideo\n      };\n    case 'SET_CURRENT_VIDEO':\n      return {\n        ...state,\n        currentVideo: action.payload\n      };\n    case 'CLEAR_ERROR':\n      return {\n        ...state,\n        error: null\n      };\n    default:\n      return state;\n  }\n};\nexport const VideoProvider = ({\n  children\n}) => {\n  _s();\n  const [state, dispatch] = useReducer(videoReducer, initialState);\n  const mapStatusToUi = status => {\n    if (!status) return 'generating';\n    const s = String(status).toUpperCase();\n    if (s === 'SUCCEEDED' || s === 'COMPLETED' || s === 'COMPLETED_SUCCESS') return 'completed';\n    if (s === 'FAILED' || s === 'CANCELLED' || s === 'CANCELED') return 'failed';\n    return 'generating';\n  };\n  const api = axios.create({\n    baseURL: '/api/videos',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    withCredentials: true\n  });\n\n  // Redirect unauthenticated users to Weam login\n  api.interceptors.response.use(response => response, error => {\n    var _error$response;\n    const status = error === null || error === void 0 ? void 0 : (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status;\n    if (status === 401) {\n      window.location.href = 'https://app.weam.ai/login';\n      return; // stop further handling\n    }\n    return Promise.reject(error);\n  });\n  const generateVideo = async (prompt, duration = 5, aspectRatio = '16:9', model = 'gen4_turbo') => {\n    try {\n      dispatch({\n        type: 'SET_LOADING',\n        payload: true\n      });\n      dispatch({\n        type: 'CLEAR_ERROR'\n      });\n      const response = await api.post('/generate', {\n        prompt,\n        duration,\n        aspectRatio,\n        model\n      });\n      const newVideoRaw = response.data.video;\n      const newVideo = {\n        ...newVideoRaw,\n        status: mapStatusToUi(newVideoRaw.status)\n      };\n      dispatch({\n        type: 'ADD_VIDEO',\n        payload: newVideo\n      });\n\n      // Show success toast\n      toast.success('Video generation started! This may take a few minutes.', {\n        duration: 5000\n      });\n\n      // Start polling for status updates\n      pollVideoStatus(newVideo.videoId);\n      return newVideo;\n    } catch (error) {\n      var _error$response2, _error$response2$data;\n      const errorMessage = ((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.error) || error.message;\n      dispatch({\n        type: 'SET_ERROR',\n        payload: errorMessage\n      });\n\n      // Show error toast\n      toast.error(`Failed to generate video: ${errorMessage}`);\n      throw error;\n    }\n  };\n  const pollVideoStatus = async (videoId, maxAttempts = 60) => {\n    let attempts = 0;\n    const pollInterval = 3000; // 3 seconds\n\n    const poll = async () => {\n      try {\n        const response = await api.get(`/${videoId}/status`);\n        const videoStatus = {\n          ...response.data,\n          status: mapStatusToUi(response.data.status)\n        };\n        dispatch({\n          type: 'UPDATE_VIDEO',\n          payload: videoStatus\n        });\n        if (videoStatus.status === 'completed') {\n          toast.success('ðŸŽ‰ Your video is ready!', {\n            duration: 6000\n          });\n          return;\n        }\n        if (videoStatus.status === 'failed') {\n          toast.error(`Video generation failed: ${videoStatus.errorMessage || 'Unknown error'}`, {\n            duration: 8000\n          });\n          return;\n        }\n        attempts++;\n        if (attempts < maxAttempts) {\n          setTimeout(poll, pollInterval);\n        } else {\n          toast.error('Video generation timed out. Please try again.', {\n            duration: 8000\n          });\n        }\n      } catch (error) {\n        console.error('Error polling video status:', error);\n        attempts++;\n        if (attempts < maxAttempts) {\n          setTimeout(poll, pollInterval);\n        } else {\n          toast.error('Lost connection to video generation. Please refresh the page.', {\n            duration: 8000\n          });\n        }\n      }\n    };\n    poll();\n  };\n  const fetchVideos = async (page = 1, limit = 10, status = null, search = null) => {\n    try {\n      dispatch({\n        type: 'SET_LOADING',\n        payload: true\n      });\n      dispatch({\n        type: 'CLEAR_ERROR'\n      });\n      const params = new URLSearchParams({\n        page: page.toString(),\n        limit: limit.toString()\n      });\n      if (status) params.append('status', status);\n      if (search) params.append('search', search);\n      const response = await api.get(`/?${params.toString()}`);\n      const videos = (response.data.videos || []).map(v => ({\n        ...v,\n        status: mapStatusToUi(v.status)\n      }));\n      dispatch({\n        type: 'SET_VIDEOS',\n        payload: {\n          videos,\n          pagination: response.data.pagination\n        }\n      });\n    } catch (error) {\n      var _error$response3, _error$response3$data;\n      const errorMessage = ((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : (_error$response3$data = _error$response3.data) === null || _error$response3$data === void 0 ? void 0 : _error$response3$data.error) || error.message;\n      dispatch({\n        type: 'SET_ERROR',\n        payload: errorMessage\n      });\n      toast.error(`Failed to load videos: ${errorMessage}`);\n    }\n  };\n  const updateVideoTitle = async (videoId, title) => {\n    try {\n      const response = await api.patch(`/${videoId}/title`, {\n        title\n      });\n      dispatch({\n        type: 'UPDATE_VIDEO',\n        payload: response.data.video\n      });\n      toast.success('Title updated successfully!');\n    } catch (error) {\n      var _error$response4, _error$response4$data;\n      const errorMessage = ((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : (_error$response4$data = _error$response4.data) === null || _error$response4$data === void 0 ? void 0 : _error$response4$data.error) || error.message;\n      toast.error(`Failed to update title: ${errorMessage}`);\n      throw error;\n    }\n  };\n  const regenerateVideo = async videoId => {\n    try {\n      dispatch({\n        type: 'SET_LOADING',\n        payload: true\n      });\n      dispatch({\n        type: 'CLEAR_ERROR'\n      });\n      const response = await api.post(`/${videoId}/regenerate`);\n      const newVideo = response.data.video;\n      dispatch({\n        type: 'ADD_VIDEO',\n        payload: newVideo\n      });\n      toast.success('Regenerating video...', {\n        duration: 3000\n      });\n      pollVideoStatus(newVideo.videoId);\n      return newVideo;\n    } catch (error) {\n      var _error$response5, _error$response5$data;\n      const errorMessage = ((_error$response5 = error.response) === null || _error$response5 === void 0 ? void 0 : (_error$response5$data = _error$response5.data) === null || _error$response5$data === void 0 ? void 0 : _error$response5$data.error) || error.message;\n      dispatch({\n        type: 'SET_ERROR',\n        payload: errorMessage\n      });\n      toast.error(`Failed to regenerate video: ${errorMessage}`);\n      throw error;\n    }\n  };\n  const deleteVideo = async videoId => {\n    try {\n      await api.delete(`/${videoId}`);\n      dispatch({\n        type: 'SET_VIDEOS',\n        payload: {\n          videos: state.videos.filter(video => video.videoId !== videoId),\n          pagination: state.pagination\n        }\n      });\n      toast.success('Video deleted successfully!');\n    } catch (error) {\n      var _error$response6, _error$response6$data;\n      const errorMessage = ((_error$response6 = error.response) === null || _error$response6 === void 0 ? void 0 : (_error$response6$data = _error$response6.data) === null || _error$response6$data === void 0 ? void 0 : _error$response6$data.error) || error.message;\n      toast.error(`Failed to delete video: ${errorMessage}`);\n      throw error;\n    }\n  };\n  const clearError = () => {\n    dispatch({\n      type: 'CLEAR_ERROR'\n    });\n  };\n  useEffect(() => {\n    fetchVideos();\n  }, []);\n  const value = {\n    ...state,\n    generateVideo,\n    fetchVideos,\n    updateVideoTitle,\n    regenerateVideo,\n    deleteVideo,\n    clearError\n  };\n  return /*#__PURE__*/_jsxDEV(VideoContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 272,\n    columnNumber: 5\n  }, this);\n};\n_s(VideoProvider, \"bgCdjuTOmPdSBRwTap80EFd9Y3U=\");\n_c = VideoProvider;\nexport const useVideo = () => {\n  _s2();\n  const context = useContext(VideoContext);\n  if (!context) {\n    throw new Error('useVideo must be used within a VideoProvider');\n  }\n  return context;\n};\n_s2(useVideo, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"VideoProvider\");","map":{"version":3,"names":["React","createContext","useContext","useReducer","useEffect","axios","toast","jsxDEV","_jsxDEV","VideoContext","initialState","videos","currentVideo","loading","error","pagination","page","limit","total","pages","videoReducer","state","action","_state$currentVideo","type","payload","map","video","videoId","VideoProvider","children","_s","dispatch","mapStatusToUi","status","s","String","toUpperCase","api","create","baseURL","headers","withCredentials","interceptors","response","use","_error$response","window","location","href","Promise","reject","generateVideo","prompt","duration","aspectRatio","model","post","newVideoRaw","data","newVideo","success","pollVideoStatus","_error$response2","_error$response2$data","errorMessage","message","maxAttempts","attempts","pollInterval","poll","get","videoStatus","setTimeout","console","fetchVideos","search","params","URLSearchParams","toString","append","v","_error$response3","_error$response3$data","updateVideoTitle","title","patch","_error$response4","_error$response4$data","regenerateVideo","_error$response5","_error$response5$data","deleteVideo","delete","filter","_error$response6","_error$response6$data","clearError","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","useVideo","_s2","context","Error","$RefreshReg$"],"sources":["/Users/kshitijvarma/Desktop/ai-doc-editor/AI-VideoGen/client/src/context/VideoContext.js"],"sourcesContent":["import React, { createContext, useContext, useReducer, useEffect } from 'react';\nimport axios from 'axios';\nimport toast from 'react-hot-toast';\n\nconst VideoContext = createContext();\n\nconst initialState = {\n  videos: [],\n  currentVideo: null,\n  loading: false,\n  error: null,\n  pagination: {\n    page: 1,\n    limit: 10,\n    total: 0,\n    pages: 0\n  }\n};\n\nconst videoReducer = (state, action) => {\n  switch (action.type) {\n    case 'SET_LOADING':\n      return { ...state, loading: action.payload };\n    case 'SET_ERROR':\n      return { ...state, error: action.payload, loading: false };\n    case 'SET_VIDEOS':\n      return { \n        ...state, \n        videos: action.payload.videos, \n        pagination: action.payload.pagination,\n        loading: false \n      };\n    case 'ADD_VIDEO':\n      return { \n        ...state, \n        videos: [action.payload, ...state.videos],\n        currentVideo: action.payload,\n        loading: false \n      };\n    case 'UPDATE_VIDEO':\n      return {\n        ...state,\n        videos: state.videos.map(video => \n          video.videoId === action.payload.videoId ? action.payload : video\n        ),\n        currentVideo: state.currentVideo?.videoId === action.payload.videoId \n          ? action.payload \n          : state.currentVideo\n      };\n    case 'SET_CURRENT_VIDEO':\n      return { ...state, currentVideo: action.payload };\n    case 'CLEAR_ERROR':\n      return { ...state, error: null };\n    default:\n      return state;\n  }\n};\n\nexport const VideoProvider = ({ children }) => {\n  const [state, dispatch] = useReducer(videoReducer, initialState);\n\n  const mapStatusToUi = (status) => {\n    if (!status) return 'generating';\n    const s = String(status).toUpperCase();\n    if (s === 'SUCCEEDED' || s === 'COMPLETED' || s === 'COMPLETED_SUCCESS') return 'completed';\n    if (s === 'FAILED' || s === 'CANCELLED' || s === 'CANCELED') return 'failed';\n    return 'generating';\n  };\n\n  const api = axios.create({\n    baseURL: '/api/videos',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    withCredentials: true\n  });\n\n  // Redirect unauthenticated users to Weam login\n  api.interceptors.response.use(\n    (response) => response,\n    (error) => {\n      const status = error?.response?.status;\n      if (status === 401) {\n        window.location.href = 'https://app.weam.ai/login';\n        return; // stop further handling\n      }\n      return Promise.reject(error);\n    }\n  );\n\n  const generateVideo = async (prompt, duration = 5, aspectRatio = '16:9', model = 'gen4_turbo') => {\n    try {\n      dispatch({ type: 'SET_LOADING', payload: true });\n      dispatch({ type: 'CLEAR_ERROR' });\n\n      const response = await api.post('/generate', {\n        prompt,\n        duration,\n        aspectRatio,\n        model\n      });\n\n      const newVideoRaw = response.data.video;\n      const newVideo = { ...newVideoRaw, status: mapStatusToUi(newVideoRaw.status) };\n      dispatch({ type: 'ADD_VIDEO', payload: newVideo });\n\n      // Show success toast\n      toast.success('Video generation started! This may take a few minutes.', {\n        duration: 5000,\n      });\n\n      // Start polling for status updates\n      pollVideoStatus(newVideo.videoId);\n\n      return newVideo;\n    } catch (error) {\n      const errorMessage = error.response?.data?.error || error.message;\n      dispatch({ type: 'SET_ERROR', payload: errorMessage });\n      \n      // Show error toast\n      toast.error(`Failed to generate video: ${errorMessage}`);\n      throw error;\n    }\n  };\n\n  const pollVideoStatus = async (videoId, maxAttempts = 60) => {\n    let attempts = 0;\n    const pollInterval = 3000; // 3 seconds\n\n    const poll = async () => {\n      try {\n        const response = await api.get(`/${videoId}/status`);\n        const videoStatus = { ...response.data, status: mapStatusToUi(response.data.status) };\n\n        dispatch({ type: 'UPDATE_VIDEO', payload: videoStatus });\n\n        if (videoStatus.status === 'completed') {\n          toast.success('ðŸŽ‰ Your video is ready!', {\n            duration: 6000,\n          });\n          return;\n        }\n\n        if (videoStatus.status === 'failed') {\n          toast.error(`Video generation failed: ${videoStatus.errorMessage || 'Unknown error'}`, {\n            duration: 8000,\n          });\n          return;\n        }\n\n        attempts++;\n        if (attempts < maxAttempts) {\n          setTimeout(poll, pollInterval);\n        } else {\n          toast.error('Video generation timed out. Please try again.', {\n            duration: 8000,\n          });\n        }\n      } catch (error) {\n        console.error('Error polling video status:', error);\n        attempts++;\n        if (attempts < maxAttempts) {\n          setTimeout(poll, pollInterval);\n        } else {\n          toast.error('Lost connection to video generation. Please refresh the page.', {\n            duration: 8000,\n          });\n        }\n      }\n    };\n\n    poll();\n  };\n\n  const fetchVideos = async (page = 1, limit = 10, status = null, search = null) => {\n    try {\n      dispatch({ type: 'SET_LOADING', payload: true });\n      dispatch({ type: 'CLEAR_ERROR' });\n\n      const params = new URLSearchParams({\n        page: page.toString(),\n        limit: limit.toString()\n      });\n\n      if (status) params.append('status', status);\n      if (search) params.append('search', search);\n\n      const response = await api.get(`/?${params.toString()}`);\n      const videos = (response.data.videos || []).map(v => ({ ...v, status: mapStatusToUi(v.status) }));\n      dispatch({ type: 'SET_VIDEOS', payload: { videos, pagination: response.data.pagination } });\n    } catch (error) {\n      const errorMessage = error.response?.data?.error || error.message;\n      dispatch({ type: 'SET_ERROR', payload: errorMessage });\n      toast.error(`Failed to load videos: ${errorMessage}`);\n    }\n  };\n\n  const updateVideoTitle = async (videoId, title) => {\n    try {\n      const response = await api.patch(`/${videoId}/title`, { title });\n      dispatch({ type: 'UPDATE_VIDEO', payload: response.data.video });\n      toast.success('Title updated successfully!');\n    } catch (error) {\n      const errorMessage = error.response?.data?.error || error.message;\n      toast.error(`Failed to update title: ${errorMessage}`);\n      throw error;\n    }\n  };\n\n  const regenerateVideo = async (videoId) => {\n    try {\n      dispatch({ type: 'SET_LOADING', payload: true });\n      dispatch({ type: 'CLEAR_ERROR' });\n\n      const response = await api.post(`/${videoId}/regenerate`);\n      const newVideo = response.data.video;\n      \n      dispatch({ type: 'ADD_VIDEO', payload: newVideo });\n      \n      toast.success('Regenerating video...', {\n        duration: 3000,\n      });\n      \n      pollVideoStatus(newVideo.videoId);\n\n      return newVideo;\n    } catch (error) {\n      const errorMessage = error.response?.data?.error || error.message;\n      dispatch({ type: 'SET_ERROR', payload: errorMessage });\n      toast.error(`Failed to regenerate video: ${errorMessage}`);\n      throw error;\n    }\n  };\n\n  const deleteVideo = async (videoId) => {\n    try {\n      await api.delete(`/${videoId}`);\n      dispatch({ \n        type: 'SET_VIDEOS', \n        payload: {\n          videos: state.videos.filter(video => video.videoId !== videoId),\n          pagination: state.pagination\n        }\n      });\n      toast.success('Video deleted successfully!');\n    } catch (error) {\n      const errorMessage = error.response?.data?.error || error.message;\n      toast.error(`Failed to delete video: ${errorMessage}`);\n      throw error;\n    }\n  };\n\n  const clearError = () => {\n    dispatch({ type: 'CLEAR_ERROR' });\n  };\n\n  useEffect(() => {\n    fetchVideos();\n  }, []);\n\n  const value = {\n    ...state,\n    generateVideo,\n    fetchVideos,\n    updateVideoTitle,\n    regenerateVideo,\n    deleteVideo,\n    clearError\n  };\n\n  return (\n    <VideoContext.Provider value={value}>\n      {children}\n    </VideoContext.Provider>\n  );\n};\n\nexport const useVideo = () => {\n  const context = useContext(VideoContext);\n  if (!context) {\n    throw new Error('useVideo must be used within a VideoProvider');\n  }\n  return context;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}