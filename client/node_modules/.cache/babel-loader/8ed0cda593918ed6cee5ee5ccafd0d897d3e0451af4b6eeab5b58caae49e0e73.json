{"ast":null,"code":"var _jsxFileName = \"/Users/kshitijvarma/Desktop/runway video apI/client/src/context/VideoContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useReducer, useEffect } from 'react';\nimport axios from 'axios';\nimport toast from 'react-hot-toast';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst VideoContext = /*#__PURE__*/createContext();\nconst initialState = {\n  videos: [],\n  currentVideo: null,\n  loading: false,\n  error: null,\n  pagination: {\n    page: 1,\n    limit: 10,\n    total: 0,\n    pages: 0\n  }\n};\nconst videoReducer = (state, action) => {\n  var _state$currentVideo;\n  switch (action.type) {\n    case 'SET_LOADING':\n      return {\n        ...state,\n        loading: action.payload\n      };\n    case 'SET_ERROR':\n      return {\n        ...state,\n        error: action.payload,\n        loading: false\n      };\n    case 'SET_VIDEOS':\n      return {\n        ...state,\n        videos: action.payload.videos,\n        pagination: action.payload.pagination,\n        loading: false\n      };\n    case 'ADD_VIDEO':\n      return {\n        ...state,\n        videos: [action.payload, ...state.videos],\n        currentVideo: action.payload,\n        loading: false\n      };\n    case 'UPDATE_VIDEO':\n      return {\n        ...state,\n        videos: state.videos.map(video => video.videoId === action.payload.videoId ? action.payload : video),\n        currentVideo: ((_state$currentVideo = state.currentVideo) === null || _state$currentVideo === void 0 ? void 0 : _state$currentVideo.videoId) === action.payload.videoId ? action.payload : state.currentVideo\n      };\n    case 'SET_CURRENT_VIDEO':\n      return {\n        ...state,\n        currentVideo: action.payload\n      };\n    case 'CLEAR_ERROR':\n      return {\n        ...state,\n        error: null\n      };\n    default:\n      return state;\n  }\n};\nexport const VideoProvider = ({\n  children\n}) => {\n  _s();\n  const [state, dispatch] = useReducer(videoReducer, initialState);\n  const api = axios.create({\n    baseURL: '/api/videos',\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  });\n  const generateVideo = async (prompt, duration = 5, aspectRatio = '16:9') => {\n    try {\n      dispatch({\n        type: 'SET_LOADING',\n        payload: true\n      });\n      dispatch({\n        type: 'CLEAR_ERROR'\n      });\n      const response = await api.post('/generate', {\n        prompt,\n        duration,\n        aspectRatio\n      });\n      const newVideo = response.data.video;\n      dispatch({\n        type: 'ADD_VIDEO',\n        payload: newVideo\n      });\n\n      // Show success toast\n      toast.success('Video generation started! This may take a few minutes.', {\n        duration: 5000\n      });\n\n      // Start polling for status updates\n      pollVideoStatus(newVideo.videoId);\n      return newVideo;\n    } catch (error) {\n      var _error$response, _error$response$data;\n      const errorMessage = ((_error$response = error.response) === null || _error$response === void 0 ? void 0 : (_error$response$data = _error$response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.error) || error.message;\n      dispatch({\n        type: 'SET_ERROR',\n        payload: errorMessage\n      });\n\n      // Show error toast\n      toast.error(`Failed to generate video: ${errorMessage}`);\n      throw error;\n    }\n  };\n  const pollVideoStatus = async (videoId, maxAttempts = 60) => {\n    let attempts = 0;\n    const pollInterval = 3000; // 3 seconds\n\n    const poll = async () => {\n      try {\n        const response = await api.get(`/${videoId}/status`);\n        const videoStatus = response.data;\n        dispatch({\n          type: 'UPDATE_VIDEO',\n          payload: videoStatus\n        });\n        if (videoStatus.status === 'completed') {\n          toast.success('ðŸŽ‰ Your video is ready!', {\n            duration: 6000\n          });\n          return;\n        }\n        if (videoStatus.status === 'failed') {\n          toast.error(`Video generation failed: ${videoStatus.errorMessage || 'Unknown error'}`, {\n            duration: 8000\n          });\n          return;\n        }\n        attempts++;\n        if (attempts < maxAttempts) {\n          setTimeout(poll, pollInterval);\n        } else {\n          toast.error('Video generation timed out. Please try again.', {\n            duration: 8000\n          });\n        }\n      } catch (error) {\n        console.error('Error polling video status:', error);\n        attempts++;\n        if (attempts < maxAttempts) {\n          setTimeout(poll, pollInterval);\n        } else {\n          toast.error('Lost connection to video generation. Please refresh the page.', {\n            duration: 8000\n          });\n        }\n      }\n    };\n    poll();\n  };\n  const fetchVideos = async (page = 1, limit = 10, status = null, search = null) => {\n    try {\n      dispatch({\n        type: 'SET_LOADING',\n        payload: true\n      });\n      dispatch({\n        type: 'CLEAR_ERROR'\n      });\n      const params = new URLSearchParams({\n        page: page.toString(),\n        limit: limit.toString()\n      });\n      if (status) params.append('status', status);\n      if (search) params.append('search', search);\n      const response = await api.get(`/?${params.toString()}`);\n      dispatch({\n        type: 'SET_VIDEOS',\n        payload: response.data\n      });\n    } catch (error) {\n      var _error$response2, _error$response2$data;\n      const errorMessage = ((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.error) || error.message;\n      dispatch({\n        type: 'SET_ERROR',\n        payload: errorMessage\n      });\n      toast.error(`Failed to load videos: ${errorMessage}`);\n    }\n  };\n  const updateVideoTitle = async (videoId, title) => {\n    try {\n      const response = await api.patch(`/${videoId}/title`, {\n        title\n      });\n      dispatch({\n        type: 'UPDATE_VIDEO',\n        payload: response.data.video\n      });\n      toast.success('Title updated successfully!');\n    } catch (error) {\n      var _error$response3, _error$response3$data;\n      const errorMessage = ((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : (_error$response3$data = _error$response3.data) === null || _error$response3$data === void 0 ? void 0 : _error$response3$data.error) || error.message;\n      toast.error(`Failed to update title: ${errorMessage}`);\n      throw error;\n    }\n  };\n  const regenerateVideo = async videoId => {\n    try {\n      dispatch({\n        type: 'SET_LOADING',\n        payload: true\n      });\n      dispatch({\n        type: 'CLEAR_ERROR'\n      });\n      const response = await api.post(`/${videoId}/regenerate`);\n      const newVideo = response.data.video;\n      dispatch({\n        type: 'ADD_VIDEO',\n        payload: newVideo\n      });\n      toast.success('Regenerating video...', {\n        duration: 3000\n      });\n      pollVideoStatus(newVideo.videoId);\n      return newVideo;\n    } catch (error) {\n      var _error$response4, _error$response4$data;\n      const errorMessage = ((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : (_error$response4$data = _error$response4.data) === null || _error$response4$data === void 0 ? void 0 : _error$response4$data.error) || error.message;\n      dispatch({\n        type: 'SET_ERROR',\n        payload: errorMessage\n      });\n      toast.error(`Failed to regenerate video: ${errorMessage}`);\n      throw error;\n    }\n  };\n  const deleteVideo = async videoId => {\n    try {\n      await api.delete(`/${videoId}`);\n      dispatch({\n        type: 'SET_VIDEOS',\n        payload: {\n          videos: state.videos.filter(video => video.videoId !== videoId),\n          pagination: state.pagination\n        }\n      });\n      toast.success('Video deleted successfully!');\n    } catch (error) {\n      var _error$response5, _error$response5$data;\n      const errorMessage = ((_error$response5 = error.response) === null || _error$response5 === void 0 ? void 0 : (_error$response5$data = _error$response5.data) === null || _error$response5$data === void 0 ? void 0 : _error$response5$data.error) || error.message;\n      toast.error(`Failed to delete video: ${errorMessage}`);\n      throw error;\n    }\n  };\n  const clearError = () => {\n    dispatch({\n      type: 'CLEAR_ERROR'\n    });\n  };\n  useEffect(() => {\n    fetchVideos();\n  }, []);\n  const value = {\n    ...state,\n    generateVideo,\n    fetchVideos,\n    updateVideoTitle,\n    regenerateVideo,\n    deleteVideo,\n    clearError\n  };\n  return /*#__PURE__*/_jsxDEV(VideoContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 247,\n    columnNumber: 5\n  }, this);\n};\n_s(VideoProvider, \"bgCdjuTOmPdSBRwTap80EFd9Y3U=\");\n_c = VideoProvider;\nexport const useVideo = () => {\n  _s2();\n  const context = useContext(VideoContext);\n  if (!context) {\n    throw new Error('useVideo must be used within a VideoProvider');\n  }\n  return context;\n};\n_s2(useVideo, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"VideoProvider\");","map":{"version":3,"names":["React","createContext","useContext","useReducer","useEffect","axios","toast","jsxDEV","_jsxDEV","VideoContext","initialState","videos","currentVideo","loading","error","pagination","page","limit","total","pages","videoReducer","state","action","_state$currentVideo","type","payload","map","video","videoId","VideoProvider","children","_s","dispatch","api","create","baseURL","headers","generateVideo","prompt","duration","aspectRatio","response","post","newVideo","data","success","pollVideoStatus","_error$response","_error$response$data","errorMessage","message","maxAttempts","attempts","pollInterval","poll","get","videoStatus","status","setTimeout","console","fetchVideos","search","params","URLSearchParams","toString","append","_error$response2","_error$response2$data","updateVideoTitle","title","patch","_error$response3","_error$response3$data","regenerateVideo","_error$response4","_error$response4$data","deleteVideo","delete","filter","_error$response5","_error$response5$data","clearError","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","useVideo","_s2","context","Error","$RefreshReg$"],"sources":["/Users/kshitijvarma/Desktop/runway video apI/client/src/context/VideoContext.js"],"sourcesContent":["import React, { createContext, useContext, useReducer, useEffect } from 'react';\nimport axios from 'axios';\nimport toast from 'react-hot-toast';\n\nconst VideoContext = createContext();\n\nconst initialState = {\n  videos: [],\n  currentVideo: null,\n  loading: false,\n  error: null,\n  pagination: {\n    page: 1,\n    limit: 10,\n    total: 0,\n    pages: 0\n  }\n};\n\nconst videoReducer = (state, action) => {\n  switch (action.type) {\n    case 'SET_LOADING':\n      return { ...state, loading: action.payload };\n    case 'SET_ERROR':\n      return { ...state, error: action.payload, loading: false };\n    case 'SET_VIDEOS':\n      return { \n        ...state, \n        videos: action.payload.videos, \n        pagination: action.payload.pagination,\n        loading: false \n      };\n    case 'ADD_VIDEO':\n      return { \n        ...state, \n        videos: [action.payload, ...state.videos],\n        currentVideo: action.payload,\n        loading: false \n      };\n    case 'UPDATE_VIDEO':\n      return {\n        ...state,\n        videos: state.videos.map(video => \n          video.videoId === action.payload.videoId ? action.payload : video\n        ),\n        currentVideo: state.currentVideo?.videoId === action.payload.videoId \n          ? action.payload \n          : state.currentVideo\n      };\n    case 'SET_CURRENT_VIDEO':\n      return { ...state, currentVideo: action.payload };\n    case 'CLEAR_ERROR':\n      return { ...state, error: null };\n    default:\n      return state;\n  }\n};\n\nexport const VideoProvider = ({ children }) => {\n  const [state, dispatch] = useReducer(videoReducer, initialState);\n\n  const api = axios.create({\n    baseURL: '/api/videos',\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  });\n\n  const generateVideo = async (prompt, duration = 5, aspectRatio = '16:9') => {\n    try {\n      dispatch({ type: 'SET_LOADING', payload: true });\n      dispatch({ type: 'CLEAR_ERROR' });\n\n      const response = await api.post('/generate', {\n        prompt,\n        duration,\n        aspectRatio\n      });\n\n      const newVideo = response.data.video;\n      dispatch({ type: 'ADD_VIDEO', payload: newVideo });\n\n      // Show success toast\n      toast.success('Video generation started! This may take a few minutes.', {\n        duration: 5000,\n      });\n\n      // Start polling for status updates\n      pollVideoStatus(newVideo.videoId);\n\n      return newVideo;\n    } catch (error) {\n      const errorMessage = error.response?.data?.error || error.message;\n      dispatch({ type: 'SET_ERROR', payload: errorMessage });\n      \n      // Show error toast\n      toast.error(`Failed to generate video: ${errorMessage}`);\n      throw error;\n    }\n  };\n\n  const pollVideoStatus = async (videoId, maxAttempts = 60) => {\n    let attempts = 0;\n    const pollInterval = 3000; // 3 seconds\n\n    const poll = async () => {\n      try {\n        const response = await api.get(`/${videoId}/status`);\n        const videoStatus = response.data;\n\n        dispatch({ type: 'UPDATE_VIDEO', payload: videoStatus });\n\n        if (videoStatus.status === 'completed') {\n          toast.success('ðŸŽ‰ Your video is ready!', {\n            duration: 6000,\n          });\n          return;\n        }\n\n        if (videoStatus.status === 'failed') {\n          toast.error(`Video generation failed: ${videoStatus.errorMessage || 'Unknown error'}`, {\n            duration: 8000,\n          });\n          return;\n        }\n\n        attempts++;\n        if (attempts < maxAttempts) {\n          setTimeout(poll, pollInterval);\n        } else {\n          toast.error('Video generation timed out. Please try again.', {\n            duration: 8000,\n          });\n        }\n      } catch (error) {\n        console.error('Error polling video status:', error);\n        attempts++;\n        if (attempts < maxAttempts) {\n          setTimeout(poll, pollInterval);\n        } else {\n          toast.error('Lost connection to video generation. Please refresh the page.', {\n            duration: 8000,\n          });\n        }\n      }\n    };\n\n    poll();\n  };\n\n  const fetchVideos = async (page = 1, limit = 10, status = null, search = null) => {\n    try {\n      dispatch({ type: 'SET_LOADING', payload: true });\n      dispatch({ type: 'CLEAR_ERROR' });\n\n      const params = new URLSearchParams({\n        page: page.toString(),\n        limit: limit.toString()\n      });\n\n      if (status) params.append('status', status);\n      if (search) params.append('search', search);\n\n      const response = await api.get(`/?${params.toString()}`);\n      dispatch({ type: 'SET_VIDEOS', payload: response.data });\n    } catch (error) {\n      const errorMessage = error.response?.data?.error || error.message;\n      dispatch({ type: 'SET_ERROR', payload: errorMessage });\n      toast.error(`Failed to load videos: ${errorMessage}`);\n    }\n  };\n\n  const updateVideoTitle = async (videoId, title) => {\n    try {\n      const response = await api.patch(`/${videoId}/title`, { title });\n      dispatch({ type: 'UPDATE_VIDEO', payload: response.data.video });\n      toast.success('Title updated successfully!');\n    } catch (error) {\n      const errorMessage = error.response?.data?.error || error.message;\n      toast.error(`Failed to update title: ${errorMessage}`);\n      throw error;\n    }\n  };\n\n  const regenerateVideo = async (videoId) => {\n    try {\n      dispatch({ type: 'SET_LOADING', payload: true });\n      dispatch({ type: 'CLEAR_ERROR' });\n\n      const response = await api.post(`/${videoId}/regenerate`);\n      const newVideo = response.data.video;\n      \n      dispatch({ type: 'ADD_VIDEO', payload: newVideo });\n      \n      toast.success('Regenerating video...', {\n        duration: 3000,\n      });\n      \n      pollVideoStatus(newVideo.videoId);\n\n      return newVideo;\n    } catch (error) {\n      const errorMessage = error.response?.data?.error || error.message;\n      dispatch({ type: 'SET_ERROR', payload: errorMessage });\n      toast.error(`Failed to regenerate video: ${errorMessage}`);\n      throw error;\n    }\n  };\n\n  const deleteVideo = async (videoId) => {\n    try {\n      await api.delete(`/${videoId}`);\n      dispatch({ \n        type: 'SET_VIDEOS', \n        payload: {\n          videos: state.videos.filter(video => video.videoId !== videoId),\n          pagination: state.pagination\n        }\n      });\n      toast.success('Video deleted successfully!');\n    } catch (error) {\n      const errorMessage = error.response?.data?.error || error.message;\n      toast.error(`Failed to delete video: ${errorMessage}`);\n      throw error;\n    }\n  };\n\n  const clearError = () => {\n    dispatch({ type: 'CLEAR_ERROR' });\n  };\n\n  useEffect(() => {\n    fetchVideos();\n  }, []);\n\n  const value = {\n    ...state,\n    generateVideo,\n    fetchVideos,\n    updateVideoTitle,\n    regenerateVideo,\n    deleteVideo,\n    clearError\n  };\n\n  return (\n    <VideoContext.Provider value={value}>\n      {children}\n    </VideoContext.Provider>\n  );\n};\n\nexport const useVideo = () => {\n  const context = useContext(VideoContext);\n  if (!context) {\n    throw new Error('useVideo must be used within a VideoProvider');\n  }\n  return context;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}